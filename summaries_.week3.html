<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Summaries Week 3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="summaries_.week3_files/libs/clipboard/clipboard.min.js"></script>
<script src="summaries_.week3_files/libs/quarto-html/quarto.js"></script>
<script src="summaries_.week3_files/libs/quarto-html/popper.min.js"></script>
<script src="summaries_.week3_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="summaries_.week3_files/libs/quarto-html/anchor.min.js"></script>
<link href="summaries_.week3_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="summaries_.week3_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="summaries_.week3_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="summaries_.week3_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="summaries_.week3_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Summaries Week 3</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="summary-1" class="level2">
<h2 class="anchored" data-anchor-id="summary-1">Summary #1</h2>
<p><a href="%22C:\Users\Adasia%20McClinton\Downloads\DaviesMeteyard_MixedModels_Revised213012020.pdf%22">“C:\Users\Adasia McClinton\Downloads\DaviesMeteyard_MixedModels_Revised213012020.pdf”</a></p>
<ul>
<li><p>Adoption of LMMs:</p>
<ul>
<li><p>Linear Mixed-effects Models (LMMs) are increasingly used in psychological science for analyzing complex, hierarchical data, such as repeated measures or multi-stage sampling designs.</p></li>
<li><p>LMMs account for both fixed effects (predictable factors) and random effects (variability between participants or stimuli), which traditional methods like ANOVA do not handle as effectively.</p></li>
</ul></li>
<li><p>Key Advantages of LMMs:</p>
<ul>
<li><p>Allow modeling of individual differences in responses across participants and stimuli.</p></li>
<li><p>Handle data with missing values or unbalanced designs better than traditional methods.</p></li>
<li><p>Provide flexibility in estimating both fixed and random effects simultaneously.</p></li>
</ul></li>
<li><p>Challenges and Concerns:</p>
<ul>
<li><p>The rapid adoption of LMMs has led to inconsistent application, with researchers facing difficulties in selecting the right model structure (e.g., random slopes vs.&nbsp;random intercepts).</p></li>
<li><p>Many researchers lack formal training in LMMs, resulting in uncertainty about model specification, convergence issues, and the interpretation of random effects.</p></li>
<li><p>Concerns over the novelty of LMMs, with limited consensus on standardized reporting or best practices across the field.</p></li>
</ul></li>
<li><p>Survey Findings:</p>
<ul>
<li><p>Survey of 163 researchers showed:</p>
<ul>
<li><p>91% had used LMMs, with most learning through workshops (68%) or self-teaching (30%).</p></li>
<li><p>Common challenges included a lack of standardized procedures (26%), model specification difficulties (25%), and inadequate knowledge (18%).</p></li>
</ul></li>
<li><p>The review of 400 papers revealed significant variation in reporting practices, with many papers omitting key information like model comparison, convergence details, and random effects structures.</p></li>
</ul></li>
<li><p>Best Practice Recommendations:</p>
<ul>
<li><p>Transparent Reporting: Researchers should clearly document their model structures (e.g., which random and fixed effects were included) and the rationale behind model selection.</p></li>
<li><p>Complete Output: Report confidence intervals, p-values, model likelihood, and F-tests when appropriate. Providing full model outputs ensures that results can be replicated and reanalyzed.</p></li>
<li><p>Preferred Reporting Formats: Use tables for clarity and ease of comparison, with written descriptions or plots as supplementary for more complex models.</p></li>
<li><p>Model Comparisons: Compare LMM results to traditional methods like ANOVA, noting any differences in significance or effect size. LMMs are often more sensitive but can sometimes be more conservative depending on random effect structures.</p></li>
</ul></li>
<li><p>Common Pitfalls:</p>
<ul>
<li><p>Overuse or misinterpretation of random effects, leading to convergence issues.</p></li>
<li><p>Failure to specify random slopes, which can reduce the accuracy of fixed effect estimates.</p></li>
<li><p>Lack of model validation or simplification when models fail to converge.</p></li>
</ul></li>
<li><p>Concerns in the Discipline:</p>
<ul>
<li><p>73% of survey respondents raised concerns about the misuse of LMMs in the field, particularly when researchers do not fully understand the technique or when reporting is inconsistent.</p></li>
<li><p>The flexibility of LMMs can lead to “researcher degrees of freedom,” increasing the risk of overfitting or p-hacking.</p></li>
</ul></li>
<li><p>Future Directions:</p>
<ul>
<li><p>The paper advocates for the establishment of standardized guidelines for implementing and reporting LMMs, ensuring that research remains reproducible.</p></li>
<li><p>Encourages the sharing of data and analysis code to facilitate collaboration and verification of model results, fostering more rigorous scientific practices.</p></li>
</ul></li>
<li><p>Conclusion:</p>
<ul>
<li>LMMs are powerful tools but require careful application. By adhering to best practice guidelines and promoting transparency in reporting, researchers can avoid inconsistencies and ensure the replicability of their findings in psychological science.</li>
</ul></li>
</ul>
</section>
<section id="summary-2" class="level2">
<h2 class="anchored" data-anchor-id="summary-2">Summary #2</h2>
<p><a href="%22C:\Users\Adasia%20McClinton\Downloads\LinearMixedModels_JDS_Dec2010.pdf%22">“C:\Users\Adasia McClinton\Downloads\LinearMixedModels_JDS_Dec2010.pdf”</a></p>
<ul>
<li><p>Definition of Mixed Effects Models:</p>
<ul>
<li><p>Mixed effects models include both fixed effects (constant across individuals) and random effects (vary between individuals/groups).</p></li>
<li><p>The distinction between fixed and random effects is context-dependent and sometimes unclear, but generally, fixed effects are consistent across all groups, while random effects vary.</p></li>
</ul></li>
<li><p>Applications of Mixed Models:</p>
<ul>
<li><p>Used in hierarchical or nested data structures (e.g., students within classes, classes within schools).</p></li>
<li><p>Repeated measures on the same individuals over time can be treated as random effects.</p></li>
</ul></li>
<li><p>Linear Mixed Effects Models (LMMs):</p>
<ul>
<li><p>LMMs model the relationship between a dependent variable and predictor variables, incorporating both fixed and random effects.</p></li>
<li><p>Similar to a General Linear Model, but with added complexity to account for random variability between groups or subjects.</p></li>
</ul></li>
<li><p>Example Model:</p>
<ul>
<li><p>The model presented uses fictional data where the outcome variable, Extroversion, is predicted by fixed effects: Openness to new experiences, Agreeableness, Social engagement, and a categorical variable, Class.</p></li>
<li><p>The random effect is nested, with Class within School.</p></li>
</ul></li>
<li><p>lme4 Package:</p>
<ul>
<li><p>The lme4 package in R is commonly used for linear mixed models. The key functions include:</p>
<ul>
<li><p><code>lmer()</code> for fitting linear mixed models.</p></li>
<li><p><code>glmer()</code> for generalized linear mixed models.</p></li>
<li><p><code>nlmer()</code> for nonlinear mixed models.</p></li>
</ul></li>
</ul></li>
<li><p>Model Fitting and Output:</p>
<ul>
<li><p>A linear mixed model (<code>lmm.2</code>) is fit using the <code>lmer()</code> function, specifying both fixed and random effects.</p></li>
<li><p>Key outputs include:</p>
<ul>
<li><p>Fixed effects coefficients, which show the relationship between predictors and the outcome.</p></li>
<li><p>Random effects estimates, which show the variability due to the grouping structure (e.g., variability across schools or classes).</p></li>
</ul></li>
</ul></li>
<li><p>Random Effects Variance:</p>
<ul>
<li><p>The variance components of random effects help determine their significance.</p></li>
<li><p>The proportion of variance attributed to random effects is assessed to decide if mixed models are appropriate.</p></li>
</ul></li>
<li><p>Intra-Class Correlation (ICC):</p>
<ul>
<li>ICC is used to measure the reliability of the grouping structure, indicating how much of the total variance can be attributed to group membership.</li>
</ul></li>
<li><p>Markov Chain Monte Carlo (MCMC):</p>
<ul>
<li>MCMC methods can be used to estimate parameters in LMMs, providing an empirical distribution of parameter estimates, also known as the posterior distribution.</li>
</ul></li>
<li><p>Model Comparison:</p>
<ul>
<li>Models can be compared using information criteria like AIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion). Lower values indicate better model fit.</li>
</ul></li>
<li><p>Interpretation of Fixed and Random Effects:</p>
<ul>
<li><p>Fixed effects are interpreted similarly to regression coefficients.</p></li>
<li><p>Random effects are considered in terms of their contribution to the overall variance and reliability of group-level estimates.</p></li>
</ul></li>
<li><p>Model Diagnostics:</p>
<ul>
<li>Residuals from the model can be analyzed to assess model fit and check for normality.</li>
</ul></li>
<li><p>Key Considerations:</p>
<ul>
<li><p>Proper reporting of LMMs includes clearly specifying the model structure and providing detailed summaries of both fixed and random effects.</p></li>
<li><p>Model validation involves checking convergence and comparing models using appropriate criteria.</p></li>
</ul></li>
</ul>
</section>
<section id="summary-3" class="level2">
<h2 class="anchored" data-anchor-id="summary-3">Summary #3</h2>
<p><a href="%22C:\Users\Adasia%20McClinton\Downloads\BU-1340-MA.pdf%22">“C:\Users\Adasia McClinton\Downloads\BU-1340-MA.pdf”</a></p>
<ul>
<li><p>Generalized Linear Mixed Models (GLMMs):</p>
<ul>
<li><p>GLMMs generalize linear models by allowing for non-normally distributed responses, non-linear links between response mean and predictors, and correlated data using random effects.</p></li>
<li><p>GLMMs include two key models: Linear Mixed Models (LMMs) and Generalized Linear Models (GLMs).</p></li>
</ul></li>
<li><p>Applications of GLMMs:</p>
<ul>
<li><p>Useful for binary, count, and other non-normal data.</p></li>
<li><p>Capable of addressing overdispersion, correlation, and random effects in data (e.g., repeated measures, longitudinal studies).</p></li>
</ul></li>
<li><p>Example:</p>
<ul>
<li><p>In an asthma study, predictors like air pollution and individual susceptibility are used to model asthma attacks (binary response).</p></li>
<li><p>GLMMs model both individual susceptibility and correlation between repeated measures on the same child.</p></li>
</ul></li>
<li><p>Estimation Methods:</p>
<ul>
<li><p>Maximum Likelihood (ML): Common for LMMs and GLMs but difficult for complex GLMMs due to high-dimensional integrals.</p></li>
<li><p>Generalized Estimating Equations (GEEs): Computationally simpler but less flexible, primarily used in longitudinal data analysis.</p></li>
<li><p>Penalized Quasi-Likelihood (PQL): Approximation method for random effects models, works well for near-normal data but not for highly non-normal data (e.g., binary).</p></li>
</ul></li>
<li><p>Fixed vs.&nbsp;Random Effects:</p>
<ul>
<li>The decision of whether to treat factors as fixed or random depends on whether they represent levels of interest or are drawn from a broader population.</li>
</ul></li>
<li><p>Challenges:</p>
<ul>
<li><p>Computational difficulties: Estimation methods, especially ML, can be complex for large models.</p></li>
<li><p>Research focus: Ongoing research on better estimation methods, including simulation-based approaches like MCMC (Markov Chain Monte Carlo).</p></li>
</ul></li>
<li><p>Conclusion:</p>
<ul>
<li>GLMMs offer flexibility in modeling a wide range of data but face challenges in computation and small sample performance. Despite this, they are increasingly useful as methods and software continue to evolve.</li>
</ul></li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>